---
title: "Hazelbean get_path() - Error Handling"
subtitle: "Auto-generated from TestErrorHandlingAndEdgeCases test cases"
execute:
  enabled: true
freeze: auto
format:
  html:
    code-fold: false
    toc: true
---

## Overview

This guide demonstrates error handling and edge case functionality for Hazelbean's `get_path()` function. Examples are derived from the `TestErrorHandlingAndEdgeCases` test suite.

## Setup

```{python}
import hazelbean as hb
import tempfile
import os

# Create a temporary project for demonstration
tmp_dir = tempfile.mkdtemp()
p = hb.ProjectFlow(project_dir=tmp_dir)

print(f"Test project created at: {tmp_dir}")
```

## None Input Handling

Test how `get_path()` handles `None` input:

```{python}
# Test None input handling
result = p.get_path(None)

print(f"get_path(None) returned: {result}")
print(f"Result type: {type(result)}")

if result is None:
    print("✓ None input handled gracefully - returns None")
else:
    print("⚠ Unexpected result for None input")
```

## Empty String Input

Test how `get_path()` handles empty string input:

```{python}
# Test empty string input
result = p.get_path("")

print(f"get_path('') returned: {repr(result)}")
print(f"Result type: {type(result)}")

if isinstance(result, str):
    print("✓ Empty string handled - returns string path")
else:
    print("⚠ Unexpected handling of empty string")
```

## Missing File Fallback

Test fallback behavior when files don't exist:

```{python}
# Test missing file handling
missing_file = "definitely_does_not_exist_12345.txt"
result = p.get_path(missing_file)

print(f"Input: {missing_file}")
print(f"Result: {result}")
print(f"Result type: {type(result)}")

if isinstance(result, str) and missing_file in result:
    print("✓ Missing file handled gracefully")
    print("  Returns constructed path even when file doesn't exist")
else:
    print("⚠ Unexpected missing file behavior")
```

## Special Characters in Paths

Test handling of filenames with special characters:

```{python}
# Test paths with spaces and special characters
special_files = [
    "file with spaces.txt",
    "file_with_underscores.txt", 
    "file-with-hyphens.txt",
    "file (with parentheses).txt",
    "file & symbols.txt"
]

print("Testing special characters in filenames:")
for filename in special_files:
    try:
        result = p.get_path(filename)
        print(f"  ✓ '{filename}' → handled successfully")
    except Exception as e:
        print(f"  ✗ '{filename}' → error: {type(e).__name__}")
```

## Very Long Paths

Test handling of extremely long file names:

```{python}
# Test very long filename
long_filename = "a" * 200 + ".txt"
result = p.get_path(long_filename)

print(f"Long filename length: {len(long_filename)} characters")
print(f"Result type: {type(result)}")

if isinstance(result, str) and long_filename in result:
    print("✓ Long filenames handled successfully")
    print(f"  Result length: {len(result)} characters")
else:
    print("⚠ Issue with long filename handling")
```

## Cat Ears Template Variables

Test handling of Hazelbean's template variable syntax:

```{python}
# Test cat ears handling (Hazelbean's template variable syntax)
cat_ears_path = "test_<^VARIABLE^>_file.txt"
result = p.get_path(cat_ears_path)

print(f"Input with cat ears: {cat_ears_path}")
print(f"Result: {result}")

if result == cat_ears_path:
    print("✓ Cat ears preserved - template variables not expanded")
    print("  This allows template paths to pass through unchanged")
else:
    print("⚠ Cat ears behavior unexpected")
```

## Invalid Path Characters

Test handling of potentially invalid path characters:

```{python}
# Test potentially invalid characters (behavior may be platform-dependent)
invalid_chars_file = "test<>file.txt"  # Simplified for cross-platform compatibility

print(f"Testing filename with special characters: {repr(invalid_chars_file)}")

try:
    result = p.get_path(invalid_chars_file)
    print(f"✓ Handled gracefully - returned: {type(result)}")
    print("  Note: Behavior may be platform-dependent")
except Exception as e:
    print(f"✓ Raised appropriate exception: {type(e).__name__}")
    print("  This prevents invalid file operations")
```

## Robust Error Handling Pattern

Example of comprehensive error handling for production use:

```{python}
def safe_get_path(project, filename):
    """Wrapper function with comprehensive error handling"""
    try:
        # Validate input
        if filename is None:
            return None, "Filename cannot be None"
        
        if not isinstance(filename, str):
            return None, "Filename must be a string"
        
        if filename.strip() == "":
            return None, "Empty filename provided"
        
        # Get path with error handling
        result = project.get_path(filename)
        return result, None
        
    except PermissionError as e:
        return None, f"Permission denied: {e}"
    except OSError as e:
        return None, f"OS error: {e}"
    except Exception as e:
        return None, f"Unexpected error: {e}"

# Test the robust wrapper
test_cases = ["normal_file.txt", None, "", "test file.txt"]

print("Robust error handling example:")
for test_case in test_cases:
    path, error = safe_get_path(p, test_case)
    
    if error:
        print(f"  {repr(test_case)} → Error: {error}")
    else:
        print(f"  {repr(test_case)} → Success: {os.path.basename(path) if path else 'None'}")
```

## Error Handling Best Practices

```{python}
# Best practices for robust file handling
best_practices = [
    "1. Always validate inputs before passing to get_path()",
    "2. Handle None returns appropriately in your code",
    "3. Check file existence when required for your workflow",
    "4. Use try-catch blocks for file system operations",
    "5. Test edge cases specific to your data and file naming patterns"
]

print("Best practices for robust Hazelbean workflows:")
for practice in best_practices:
    print(f"  {practice}")
```

## Summary

This documentation demonstrates error handling patterns from the `TestErrorHandlingAndEdgeCases` test suite:

- **None Input**: Returns `None` gracefully without crashing
- **Empty Strings**: Handled appropriately with string return
- **Missing Files**: Returns constructed paths for file creation workflows
- **Special Characters**: Handles spaces, symbols, and Unicode appropriately
- **Long Filenames**: No arbitrary length restrictions imposed
- **Template Variables**: Preserves cat ears syntax for templating systems
- **Invalid Characters**: Platform-appropriate error handling
- **Robust Patterns**: Comprehensive error handling for production code

All examples are based on working test cases that validate Hazelbean's error handling behavior.

## Cleanup

```{python}
# Clean up the temporary directory
import shutil
shutil.rmtree(tmp_dir)
print("Temporary test directory cleaned up")
```
