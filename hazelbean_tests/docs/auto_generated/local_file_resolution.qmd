---
title: "Hazelbean get_path() - Local File Resolution"
subtitle: "Auto-generated from TestLocalFileResolution test cases"
execute:
  enabled: true
freeze: auto
format:
  html:
    code-fold: false
    toc: true
---

## Overview

This guide demonstrates local file resolution functionality for Hazelbean's `get_path()` function. Examples are derived from the `TestLocalFileResolution` test suite.

## Setup

```{python}
import hazelbean as hb
import tempfile
import os
from pathlib import Path

# Create a temporary project for demonstration
tmp_dir = tempfile.mkdtemp()
p = hb.ProjectFlow(project_dir=tmp_dir)

# Create test directory structure
os.makedirs(os.path.join(tmp_dir, "intermediate"), exist_ok=True)
os.makedirs(os.path.join(tmp_dir, "input"), exist_ok=True)

# Create test files in different directories
with open(os.path.join(tmp_dir, "test_cur_dir.txt"), 'w') as f:
    f.write("current directory content")
    
with open(os.path.join(tmp_dir, "intermediate", "test_intermediate.txt"), 'w') as f:
    f.write("intermediate content")
    
with open(os.path.join(tmp_dir, "input", "test_input.txt"), 'w') as f:
    f.write("input content")

print(f"Test project created at: {tmp_dir}")
print("Created test files in current, intermediate, and input directories")
```

## File in Current Directory

Test resolving a file in the current project directory:

```{python}
# Test resolving file in current project directory
test_file = "test_cur_dir.txt"
resolved_path = p.get_path(test_file)

print(f"Input file: {test_file}")
print(f"Resolved path: {resolved_path}")
print(f"File exists: {os.path.exists(resolved_path)}")

# Verify the file is in the correct location
if test_file in resolved_path:
    print("✓ Filename found in resolved path")
if tmp_dir in resolved_path:
    print("✓ Project directory found in resolved path")
```

## File in Intermediate Directory

Test resolving a file in the intermediate directory:

```{python}
# Test resolving file in intermediate directory  
test_file = "test_intermediate.txt"
resolved_path = p.get_path(test_file)

print(f"Input file: {test_file}")
print(f"Resolved path: {resolved_path}")
print(f"File exists: {os.path.exists(resolved_path)}")

# Verify it found the intermediate directory
if "intermediate" in resolved_path:
    print("✓ Found file in intermediate directory")
```

## File in Input Directory

Test resolving a file in the input directory:

```{python}
# Test resolving file in input directory
test_file = "test_input.txt"  
resolved_path = p.get_path(test_file)

print(f"Input file: {test_file}")
print(f"Resolved path: {resolved_path}")
print(f"File exists: {os.path.exists(resolved_path)}")

# Verify it found the input directory
if "input" in resolved_path:
    print("✓ Found file in input directory")
```

## Directory Search Priority

Test that directories are searched in the correct priority order:

```{python}
# Create same-named file in multiple directories to test priority
priority_file = "priority_test.txt"

# Create in input dir (lower priority)
input_path = os.path.join(tmp_dir, "input", priority_file)
with open(input_path, 'w') as f:
    f.write("input content")

# Create in intermediate dir (higher priority) 
intermediate_path = os.path.join(tmp_dir, "intermediate", priority_file)
with open(intermediate_path, 'w') as f:
    f.write("intermediate content")

# Test resolution - should find intermediate first
resolved_path = p.get_path(priority_file)

print(f"Input file: {priority_file}")
print(f"Resolved path: {resolved_path}")

# Check which one was found
with open(resolved_path, 'r') as f:
    content = f.read()
    
if "intermediate" in resolved_path and content == "intermediate content":
    print("✓ Correctly found intermediate directory file (higher priority)")
else:
    print("✗ Priority order issue")
```

## Relative Paths with Subdirectories

Test resolving relative paths with subdirectories:

```{python}
# Create nested directory structure
subdir = os.path.join(tmp_dir, "intermediate", "subdir")
os.makedirs(subdir, exist_ok=True)

nested_file = os.path.join(subdir, "nested_test.txt")
with open(nested_file, 'w') as f:
    f.write("nested content")

# Test resolution with relative path including subdirectory
resolved_path = p.get_path("subdir/nested_test.txt")

print(f"Input path: subdir/nested_test.txt")
print(f"Resolved path: {resolved_path}")
print(f"File exists: {os.path.exists(resolved_path)}")

if "nested_test.txt" in resolved_path:
    print("✓ Successfully resolved nested file path")
```

## Join Path Arguments

Test `get_path()` with additional join path arguments:

```{python}
# Create test subdirectory and file
test_subdir = os.path.join(tmp_dir, "intermediate", "test_subdir")
os.makedirs(test_subdir, exist_ok=True)

joined_file = os.path.join(test_subdir, "joined_test.txt")
with open(joined_file, 'w') as f:
    f.write("joined content")

# Test with separate arguments that get joined
resolved_path = p.get_path("test_subdir", "joined_test.txt")

print(f"Input args: 'test_subdir', 'joined_test.txt'")
print(f"Resolved path: {resolved_path}")
print(f"File exists: {os.path.exists(resolved_path)}")

if "joined_test.txt" in resolved_path:
    print("✓ Successfully joined path arguments")
```

## Directory Search Order Summary

The `get_path()` function searches directories in this priority order:

```{python}
# Show the search order
search_order = [
    "1. Current directory (project root)",
    "2. Intermediate directory (for temporary/processing files)",
    "3. Input directory (for input data)",
    "4. Base data directory (for reference datasets)"
]

print("Directory search priority:")
for item in search_order:
    print(f"  {item}")

print(f"\nExample paths for current project:")
print(f"  Current: {tmp_dir}")
print(f"  Intermediate: {os.path.join(tmp_dir, 'intermediate')}")
print(f"  Input: {os.path.join(tmp_dir, 'input')}")
```

## Summary

This documentation demonstrates local file resolution patterns from the `TestLocalFileResolution` test suite:

- **Current Directory Resolution**: Files in the project root are found first
- **Intermediate Directory**: Processing/temporary files have second priority  
- **Input Directory**: Input data files have third priority
- **Directory Priority**: Higher priority directories are searched first
- **Subdirectory Support**: Relative paths with subdirectories work correctly
- **Path Joining**: Multiple arguments are joined into single paths

All examples are based on working test cases that validate Hazelbean's file resolution behavior.

## Cleanup

```{python}
# Clean up the temporary directory
import shutil
shutil.rmtree(tmp_dir)
print("Temporary test directory cleaned up")
```
